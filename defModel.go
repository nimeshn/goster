package main

import (
	"errors"
	"fmt"
)

type ViewOptions struct {
	Index  bool
	Create bool
	View   bool
	Edit   bool
	Remove bool
}

type Model struct {
	Name         string      `json:"name"`
	DisplayName  string      `json:"displayName"`
	Fields       []*Field    `json:"fields"`
	Options      ViewOptions `json:"viewOptions"`
	IsRestricted bool        `json:"adminOnly"`
	HasMany      string      `json:"detailsModel"`
	BelongsTo    string      `json:"masterModel"`
	ViewType     IndexView   `json:"indexDisplayType"`
	appRef       *App
}

func (m *Model) AddField(field *Field) {
	fld := m.GetField(field.Name)
	if fld != nil {
		errors.New(fmt.Sprintf("Add Failed as field %s exists already in the model %s", field.Name, m.Name))
		return
	}
	m.Fields = append(m.Fields, field)
}

func (m *Model) PrependField(field *Field) {
	fld := m.GetField(field.Name)
	if fld != nil {
		errors.New(fmt.Sprintf("Prepend Failed as field %s exists already in the model %s", field.Name, m.Name))
		return
	}
	m.Fields = append([]*Field{field}, m.Fields...)
}

func (m *Model) ValidateRelations() (valid bool, err error) {
	if m.HasMany != "" {
		mod := m.appRef.GetModel(m.HasMany)
		valid = (mod != nil && mod.BelongsTo == m.HasMany)
		if !valid {
			err = errors.New(fmt.Sprintf("%s has many relation %s does not exist", m.Name, m.HasMany))
		}
	}
	if m.BelongsTo != "" {
		mod := m.appRef.GetModel(m.BelongsTo)
		valid = (mod != nil && mod.HasMany == m.BelongsTo)
		if !valid {
			err = errors.New(fmt.Sprintf("%s belongs to relation %s does not exist", m.Name, m.BelongsTo))
		}
	}
	return
}

func (m *Model) DeleteField(name string) {
	for index, val := range m.Fields {
		if val.Name == name {
			m.Fields = append(m.Fields[:index], m.Fields[index+1:]...)
			return
		}
	}
}

func (m *Model) GetField(name string) *Field {
	for _, val := range m.Fields {
		if val.Name == name {
			return val
		}
	}
	return nil
}

func (m *Model) SaveField(field *Field) {
	for index, fld := range m.Fields {
		if fld.Name == field.Name {
			m.Fields[index] = field
			return
		}
	}
}

func (m *Model) GetIndexFieldsCount() (count int) {
	for _, fld := range m.Fields {
		if !fld.HideInIndex {
			count++
		}
	}
	return
}

func (m *Model) AutoGenerateFields() {
	//add id field
	id := &Field{
		Name:          "id",
		Type:          Integer,
		AutoGenerated: true,
		Identity:      true,
		HideInEdit:    true,
		HideInIndex:   true,
	}
	if m.GetField("id") != nil {
		m.SaveField(id)
	} else {
		m.PrependField(id)
	}
	//add createdAt field
	createdAt := &Field{
		Name:          "createdAt",
		Type:          Date,
		AutoGenerated: true,
		Identity:      true,
		HideInEdit:    true,
		HideInIndex:   true,
	}
	if m.GetField("createdAt") != nil {
		m.SaveField(createdAt)
	} else {
		m.AddField(createdAt)
	}
	//add modifiedAt field
	modifiedAt := &Field{
		Name:          "modifiedAt",
		Type:          Date,
		AutoGenerated: true,
		Identity:      true,
		HideInEdit:    true,
		HideInIndex:   true,
	}
	if m.GetField("modifiedAt") != nil {
		m.SaveField(modifiedAt)
	} else {
		m.AddField(modifiedAt)
	}
}

func NewModel() *Model {
	return &Model{Fields: []*Field{}}
}
