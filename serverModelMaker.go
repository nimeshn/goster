package main

import (
	"fmt"
	"path"
	"strings"
)

type ServerModelSettings struct {
	idCol              string
	indexFunc          string
	getFunc            string
	createFunc         string
	updateFunc         string
	deleteFunc         string
	getFuncFormat      string
	deleteFuncFormat   string
	indexRoute         string
	getRoute           string
	createRoute        string
	updateRoute        string
	deleteRoute        string
	controllerVar      string
	controllerName     string
	controllerFileName string
	modelName          string
	modelFileName      string
	scanParams         string
	updateParams       string
	updateList         string
	selectList         string
	insertList         string
	placeholderList    string
}

func (m *Model) GetServerSettings() (sms *ServerModelSettings) {
	sms = &ServerModelSettings{
		idCol:              fmt.Sprintf("%sId", m.Name),
		indexFunc:          "GetAll",
		getFunc:            "GetById",
		createFunc:         "Create",
		updateFunc:         "Update",
		deleteFunc:         "DeleteById",
		getFuncFormat:      "GetBy%s",
		deleteFuncFormat:   "DeleteBy%s",
		indexRoute:         fmt.Sprintf("/%s", m.Name),
		getRoute:           fmt.Sprintf("/%s/:%s", m.Name, fmt.Sprintf("%sId", m.Name)),
		createRoute:        fmt.Sprintf("/%s", m.Name),
		updateRoute:        fmt.Sprintf("/%s", m.Name),
		deleteRoute:        fmt.Sprintf("/%s/:%s", m.Name, fmt.Sprintf("%sId", m.Name)),
		controllerVar:      fmt.Sprintf("%sController", m.Name),
		controllerName:     fmt.Sprintf("%sController", strings.Title(m.Name)),
		controllerFileName: fmt.Sprintf("%sController.go", m.Name),
		modelName:          fmt.Sprintf("%sModel", strings.Title(m.Name)),
		modelFileName:      fmt.Sprintf("%sModel.go", m.Name),
	}
	for _, fld := range m.Fields {
		sms.scanParams += fmt.Sprintf("&%s.%s,", m.Name, strings.Title(fld.Name))
		sms.selectList += fmt.Sprintf("%s,", fld.Name)
		if fld.AutoGenerated && fld.Type == Integer { //leave id column
			continue
		}
		sms.updateParams += fmt.Sprintf("%s.%s,", m.Name, strings.Title(fld.Name))
		sms.updateList += fmt.Sprintf("%s=?,", fld.Name)
		sms.insertList += fmt.Sprintf("%s,", fld.Name)
		sms.placeholderList += "?,"
	}
	sms.scanParams = sms.scanParams[:len(sms.scanParams)-1]
	sms.updateParams = sms.updateParams[:len(sms.updateParams)-1]
	sms.updateList = sms.updateList[:len(sms.updateList)-1]
	sms.selectList = sms.selectList[:len(sms.selectList)-1]
	sms.insertList = sms.insertList[:len(sms.insertList)-1]
	sms.placeholderList = sms.placeholderList[:len(sms.placeholderList)-1]
	return
}

func (m *Model) GetServerModel(sm *ServerModelSettings) (fileName, goCode string) {
	fileName = path.Join(m.appRef.GetServerSettings().directories["server"], sm.modelFileName)

	fieldDefs := ""
	fieldChecks := ""
	imports := ""
	for _, fld := range m.Fields {
		field := strings.Title(fld.Name)

		fieldDefs += fmt.Sprintln()
		if fld.Type == Boolean {
			fieldDefs += fmt.Sprintf(`%s bool`, field)
		} else if fld.Type == Date {
			fieldDefs += fmt.Sprintf(`%s time.Time`, field)
			imports = `import (
					"time"
					)`
		} else if fld.Type == Integer {
			fieldDefs += fmt.Sprintf(`%s uint64`, field)
		} else if fld.Type == Float {
			fieldDefs += fmt.Sprintf(`%s float64`, field)
		} else if fld.Type == String {
			fieldDefs += fmt.Sprintf(`%s string`, field)
		} else {
			fieldDefs += fmt.Sprintf(`%s string`, field)
		}
		fieldDefs += fmt.Sprintf(" `json:\"%s\"` ", fld.Name)

		if fld.Validator != nil {
			fieldDefs += ` //`
			if fld.Validator.MinLen > 0 {
				fieldDefs += fmt.Sprintf(` minlength="%d",`, fld.Validator.MinLen)
			}
			if fld.Validator.MaxLen > 0 {
				fieldDefs += fmt.Sprintf(` maxlength="%d",`, fld.Validator.MaxLen)
			}
			if fld.Validator.MinValue > 0 {
				fieldDefs += fmt.Sprintf(` min="%d",`, fld.Validator.MinValue)
			}
			if fld.Validator.MaxValue > 0 {
				fieldDefs += fmt.Sprintf(` max="%d",`, fld.Validator.MaxValue)
			}
			if fld.Validator.Email {
				fieldDefs += ` valid email,`
			}
			if fld.Validator.Url {
				fieldDefs += ` valid url,`
			}
			if fld.Validator.IsAlpha {
				fieldDefs += ` isAlpha,`
			}
			if fld.Validator.IsAlphaNumeric {
				fieldDefs += ` isAlphaNumeric,`
			}
			if fld.Validator.Required {
				fieldDefs += ` required,`
			}
		}
		fieldChecks += fld.GetServerValidation(sm) + fmt.Sprintln()
	}
	fieldDefs += fmt.Sprintln()

	goCode = fmt.Sprintf(`package main

			%s

			type %s struct{%s}

			//Validate data for this model
			func (m *%s) Validate() (ok bool, modelErrors []string){
				%s
				ok = (len(modelErrors) == 0)
				if ok {
					modelErrors=nil
				}
				return
			}`, imports, sm.modelName, fieldDefs, sm.modelName, fieldChecks)

	return
}

func (m *Model) GetUniqueFieldAction(sm *ServerModelSettings) (get, del string, funcs string) {
	for _, fld := range m.Fields {
		if !fld.Unique {
			continue
		}
		parse := ""
		dataType := ""
		getFunc := fmt.Sprintf(sm.getFuncFormat, strings.Title(fld.Name))
		deleteFunc := fmt.Sprintf(sm.deleteFuncFormat, strings.Title(fld.Name))
		switch fld.Type {
		case String:
			parse = fmt.Sprintf(`%s := requestURL`, fld.Name)
			dataType = "string"
		case Date, Boolean, Float, Integer:
			switch fld.Type {
			case Date:
				parse = fmt.Sprintf(`%s, _ := time.Parse(longTimeForm, requestURL)`, fld.Name, fld.Name)
				dataType = "time.Time"
			case Boolean:
				parse = fmt.Sprintf(`%s, _ := strconv.ParseBool(requestURL)`, fld.Name, fld.Name)
				dataType = "bool"
			case Float:
				parse = fmt.Sprintf(`%s, _ := strconv.ParseFloat(requestURL, 64)`, fld.Name, fld.Name)
				dataType = "float64"
			case Integer:
				if fld.AutoGenerated {
					parse = fmt.Sprintf(`%s, _ := strconv.ParseUint(requestURL, 10, 64)`, fld.Name, fld.Name)
					dataType = "int64"
				} else {
					parse = fmt.Sprintf(`%s, _ := strconv.ParseInt(requestURL, 10, 64)`, fld.Name, fld.Name)
					dataType = "uint64"
				}
			}
		}
		get += fmt.Sprintf(
			`if requestField == "%s" {
				if requestURL != "" {
					%s
					result, err:=c.%s(%s)
					if result==nil && err==nil{
						rw.WriteHeader(http.StatusNotFound)
					}
					SendResult(rw, result, err)
					return
				}
			}`, fld.Name, parse, getFunc, fld.Name) + fmt.Sprintln()
		del += fmt.Sprintf(
			`if requestField == "%s" {
				if requestURL != "" {
					%s
					result, err:=c.%s(%s)
					SendResult(rw, result, err)
					return
				}
			}`, fld.Name, parse, deleteFunc, fld.Name) + fmt.Sprintln()

		funcs += fmt.Sprintf(
			`//function to Get model entity
			func (c *%s) %s(%s %s) (%s *%s, err error){
				%s = new(%s)
				err=GetDB().QueryRow(c.Queries["mysql"]["getBy%s"], %s).
					Scan(%s)
				if err!=nil{
					%s = nil
					if err == sql.ErrNoRows {
						err=nil
					}
					return
				}
				fmt.Println("%s.%s executed")
				return
			}`, sm.controllerName, getFunc, fld.Name, dataType, m.Name, sm.modelName,
			m.Name, sm.modelName, strings.Title(fld.Name), fld.Name, sm.scanParams, m.Name,
			sm.controllerName, getFunc) + fmt.Sprintln() +

			fmt.Sprintf(
				`//function to delete model entity
			func (c *%s) %s(%s %s) (ok bool, err error){
				_, err = GetDB().Exec(c.Queries["mysql"]["deleteBy%s"], %s)
				if err!=nil{return}
				fmt.Println("%s.%s executed")						
				return true, nil
			}`, sm.controllerName, deleteFunc, fld.Name, dataType,
				strings.Title(fld.Name), fld.Name,
				sm.controllerName, deleteFunc)
	}
	return
}

func (m *Model) GetServeHTTP(sm *ServerModelSettings) (timePack, uniqueFuncs, serveHTTP string) {
	formFld := ""
	timePack = ""
	for _, fld := range m.Fields {
		parse := ""
		switch fld.Type {
		case String:
			formFld += fmt.Sprintf(`model.%s = req.PostFormValue("%s")`, strings.Title(fld.Name), fld.Name) + fmt.Sprintln()
		case Date, Boolean, Float, Integer:
			switch fld.Type {
			case Date:
				parse = fmt.Sprintf(`%s, _ := time.Parse(longTimeForm, req.PostFormValue("%s"))`, fld.Name, fld.Name)
				timePack = `"time"`
			case Boolean:
				parse = fmt.Sprintf(`%s, _ := strconv.ParseBool(req.PostFormValue("%s"))`, fld.Name, fld.Name)
			case Float:
				parse = fmt.Sprintf(`%s, _ := strconv.ParseFloat(req.PostFormValue("%s"), 64)`, fld.Name, fld.Name)
			case Integer:
				if fld.AutoGenerated {
					parse = fmt.Sprintf(`%s, _ := strconv.ParseUint(req.PostFormValue("%s"), 10, 64)`, fld.Name, fld.Name)
				} else {
					parse = fmt.Sprintf(`%s, _ := strconv.ParseInt(req.PostFormValue("%s"), 10, 64)`, fld.Name, fld.Name)
				}
			}
			formFld += fmt.Sprintf(
				`if req.PostFormValue("%s") != "" {
							%s
							model.%s = %s
				}`, fld.Name, parse, strings.Title(fld.Name), fld.Name) + fmt.Sprintln()
		}
	}

	uniqueGet, uniqueDel, uniqueFuncs := m.GetUniqueFieldAction(sm)

	serveHTTP = fmt.Sprintf(
		`//http Request handler for %s
		func (c *%s) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
			var model %s
			urlArr := strings.Split(req.URL.String(), "/")
			requestURL, requestField := "", ""
			if len(urlArr) > 1{
				requestField = urlArr[0]
				requestURL = urlArr[1]
			}else{
				requestURL = urlArr[0]
			}

			switch req.Method {
			case "POST", "PUT" :
				contentType := strings.ToLower(req.Header["Content-Type"][0])
				switch {
				case strings.Contains(contentType, "application/json"),
					strings.Contains(contentType, "text/plain"):
					json.NewDecoder(req.Body).Decode(&model)
				case strings.Contains(contentType, "application/x-www-form-urlencoded"):
					%s
				case strings.Contains(contentType, "multipart-form-data"):
				}
				var dataErrors []string
				var err error
				if req.Method == "POST" {
					dataErrors, err=c.%s(&model)
				} else {
					dataErrors, err=c.%s(&model)
				}
				if dataErrors!=nil{
					rw.WriteHeader(http.StatusBadRequest)
				}
				SendResult(rw, dataErrors, err)
				return
			case "GET":
				if requestField == "" {
					if requestURL == "" {
						result, err:=c.%s()
						if result==nil && err==nil{
							rw.WriteHeader(http.StatusNotFound)
						}
						SendResult(rw, result, err)
						return
					} else{
						id, _ := strconv.ParseUint(requestURL, 10, 64)
						result, err:=c.%s(id)
						if result==nil && err==nil{
							rw.WriteHeader(http.StatusNotFound)
						}
						SendResult(rw, result, err)
						return
					}
				}
				%s
			case "DELETE":
				if requestField == "" {
					if requestURL != "" {
						id, _ := strconv.ParseUint(requestURL, 10, 64)
						result, err:=c.%s(id)
						SendResult(rw, result, err)
						return
					}
				}
				%s
			case "PATCH":
			}

			http.Error(rw, "Invalid resource url", http.StatusNotFound)
		}`, m.Name, sm.controllerName, sm.modelName, formFld, sm.createFunc, sm.updateFunc,
		sm.indexFunc, sm.getFunc, uniqueGet, sm.deleteFunc, uniqueDel)
	return
}

func (m *Model) GetServerQueries(sm *ServerModelSettings) (queries string) {
	uniqueQry := ""
	for _, fld := range m.Fields {
		if fld.Unique {
			uniqueQry += fmt.Sprintf(
				`"getBy%s":    "SELECT %s FROM %s WHERE %s = ?",
				"deleteBy%s": "DELETE %s WHERE %s = ?",`,
				strings.Title(fld.Name), sm.selectList, m.Name, fld.Name,
				strings.Title(fld.Name), m.Name, fld.Name) + fmt.Sprintln()
		}
	}
	queries = fmt.Sprintf(
		`"mysql": map[string]string{
			"index":  "SELECT %s FROM %s",
			"get":    "SELECT %s FROM %s WHERE id = ?",
			"create": "INSERT INTO %s(%s) VALUES (%s)",
			"update": "UPDATE %s SET %s WHERE id = ?",
			"delete": "DELETE FROM %s WHERE id = ?",
			%s
		},`, sm.selectList, m.Name, sm.selectList, m.Name, m.Name, sm.insertList, sm.placeholderList,
		m.Name, sm.updateList, m.Name, uniqueQry)

	return
}

func (m *Model) GetServerController(sm *ServerModelSettings) (fileName, goCode string) {
	fileName = path.Join(m.appRef.GetServerSettings().directories["server"], sm.controllerFileName)

	//modelListFunc
	indexFunc := fmt.Sprintf(
		`//function to Get List of model
		func (c *%s) %s() (%sList []*%s, err error){
			rows, err := GetDB().Query(c.Queries["mysql"]["index"])
			if err!=nil{return}
			defer rows.Close()
			for rows.Next() {
				%s := new(%s)
				err = rows.Scan(%s)
				if err!=nil{return}
				%sList = append(%sList,%s)
			}
			err=rows.Err()
			if err!=nil{return}
			fmt.Println("%s.%s executed:", %sList)
			return
		}`, sm.controllerName, sm.indexFunc, m.Name, sm.modelName,
		m.Name, sm.modelName, sm.scanParams, m.Name, m.Name, m.Name,
		sm.controllerName, sm.indexFunc, m.Name)

	//modelLoadFunc
	getFunc := fmt.Sprintf(
		`//function to Get model entity by id
		func (c *%s) %s(%s uint64) (%s *%s, err error){
			%s = new(%s)
			err=GetDB().QueryRow(c.Queries["mysql"]["get"], %s).
				Scan(%s)				
			if err!=nil{
				%s = nil
				if err == sql.ErrNoRows {
					err = nil
				} 
				return
			}
			fmt.Println("%s.%s executed", %s)
			return
		}`, sm.controllerName, sm.getFunc, sm.idCol, m.Name, sm.modelName, m.Name, sm.modelName,
		sm.idCol, sm.scanParams, m.Name,
		sm.controllerName, sm.getFunc, m.Name)

	//modelNewFunc
	createFunc := fmt.Sprintf(
		`//function to Create New model entity
		func (c *%s) %s(%s *%s) (modelErrors []string, err error){
			fmt.Println("%s.%s executed")
			ok, modelErrors := %s.Validate()
			if !ok{
				return
			}			
			res, err := GetDB().Exec(c.Queries["mysql"]["create"], %s)
			if err!=nil{return}
			lastId, err := res.LastInsertId()
			if err!=nil{return}
			fmt.Println("Created with new Id:", lastId)
			return
		}`, sm.controllerName, sm.createFunc, m.Name, sm.modelName, sm.controllerName, sm.createFunc, m.Name, sm.updateParams)

	//modelSaveFunc
	updateFunc := fmt.Sprintf(
		`//function to save model entity
		func (c *%s) %s(%s *%s) (modelErrors []string, err error){
			fmt.Println("%s.%s executed")
			ok, modelErrors := %s.Validate()
			if !ok{
				return
			}			
			_, err = GetDB().Exec(c.Queries["mysql"]["update"], %s, %s.Id)
			if err!=nil{return}
			return
		}`, sm.controllerName, sm.updateFunc, m.Name, sm.modelName, sm.controllerName, sm.updateFunc, m.Name, sm.updateParams, m.Name)

	//modelDeleteFunc
	deleteFunc := fmt.Sprintf(
		`//function to delete model entity by id
		func (c *%s) %s(%s uint64) (ok bool, err error){
			_, err = GetDB().Exec(c.Queries["mysql"]["delete"], %s)
			if err!=nil{return}
			fmt.Println("%s.%s executed")						
			return true, nil
		}`, sm.controllerName, sm.deleteFunc, sm.idCol, sm.idCol, sm.controllerName, sm.deleteFunc)

	timePack, uniqueFuncs, serveHTTP := m.GetServeHTTP(sm)

	goCode = fmt.Sprintf(`package main
		
			import(
				"database/sql"
				"encoding/json"
				"strings"
				"net/http"
				"fmt"
				"strconv"
				%s
			)

			type %s struct{
				Name string
				Queries map[string]map[string]string
			}

			var (
				%s *%s = &%s{
					Name:"%s",
					Queries: map[string]map[string]string{
						%s
					},
				}
			)`, timePack, sm.controllerName, sm.controllerVar, sm.controllerName, sm.controllerName,
		sm.controllerName, m.GetServerQueries(sm))

	goCode += fmt.Sprintln() + serveHTTP + fmt.Sprintln() + indexFunc + fmt.Sprintln() + getFunc + fmt.Sprintln() +
		createFunc + fmt.Sprintln() + updateFunc + fmt.Sprintln() + deleteFunc + fmt.Sprintln() + uniqueFuncs

	return
}

func (m *Model) GetServerRoutes(sa *ServerAppSettings) (routes string) {
	ss := m.GetServerSettings()
	handlerPath := path.Join(sa.apiPath, m.Name)
	indexRoute := fmt.Sprintf(
		`//routes handler for %s
		http.Handle("%s/", http.StripPrefix("%s/", %s))
		http.Handle("%s", http.StripPrefix("%s", %s))`,
		m.Name, handlerPath, handlerPath, ss.controllerVar,
		handlerPath, handlerPath, ss.controllerVar)

	routes = indexRoute + fmt.Sprintln()
	return
}
