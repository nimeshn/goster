package main

import (
	"errors"
	"fmt"
)

type ViewOptions struct {
	Index  bool
	Create bool
	View   bool
	Edit   bool
	Remove bool
}

type FieldValidation struct {
	IsAlpha        bool
	IsAlphaNumeric bool
	Url            bool
	Email          bool
	Unique         bool
	Required       bool
	MinLen         int
	MaxLen         int
	MinValue       int
	MaxValue       int
}

type Field struct {
	Name          string
	DisplayName   string
	ShowInIndex   bool
	AutoGenerated bool
	Type          Types
	Validator     *FieldValidation
}

type Model struct {
	Name             string `json:"name"`
	DisplayName      string
	Fields           []*Field
	Options          ViewOptions
	IncludeTimeStamp bool
	IsRestricted     bool
	HasMany          string
	BelongsTo        string
	ViewType         IndexView
}

type App struct {
	Name        string
	DisplayName string
	CompanyName string
	VersionNo   string
	Models      []*Model
}

var (
	app App = App{
		Name:        "SampleApp",
		DisplayName: "SampleApp",
		CompanyName: "Sample Company",
		VersionNo:   "V1.0",
		Models:      []*Model{},
	}
)

func (a *App) AddModel(model *Model) {
	mod := a.GetModel(model.Name)
	if mod != nil {
		errors.New(fmt.Sprintf("Add Failed as model %s exists already in the App", model.Name))
		return
	}
	a.Models = append(a.Models, model)
}

func (a *App) DeleteModel(name string) {
	for index, val := range a.Models {
		if val.Name == name {
			a.Models = append(a.Models[:index], a.Models[index+1:]...)
			return
		}
	}
}

func (a *App) GetModel(name string) *Model {
	for _, val := range a.Models {
		if val.Name == name {
			return val
		}
	}
	return nil
}

func (a *App) SaveModel(model *Model) {
	for index, mod := range a.Models {
		if mod.Name == model.Name {
			a.Models[index] = model
			return
		}
	}
}

func (m *Model) AddField(field *Field) {
	fld := m.GetField(field.Name)
	if fld != nil {
		errors.New(fmt.Sprintf("Add Failed as field %s exists already in the model %s", field.Name, m.Name))
		return
	}
	m.Fields = append(m.Fields, field)
}

func (m *Model) ValidateRelations() (valid bool, err error) {
	if m.HasMany != "" {
		mod := app.GetModel(m.HasMany)
		valid = (mod != nil && mod.BelongsTo == m.HasMany)
		if !valid {
			err = errors.New(fmt.Sprintf("%s has many relation %s does not exist", m.Name, m.HasMany))
		}
	}
	if m.BelongsTo != "" {
		mod := app.GetModel(m.BelongsTo)
		valid = (mod != nil && mod.HasMany == m.BelongsTo)
		if !valid {
			err = errors.New(fmt.Sprintf("%s belongs to relation %s does not exist", m.Name, m.BelongsTo))
		}
	}
	return
}

func (m *Model) DeleteField(name string) {
	for index, val := range m.Fields {
		if val.Name == name {
			m.Fields = append(m.Fields[:index], m.Fields[index+1:]...)
			return
		}
	}
}

func (m *Model) GetField(name string) *Field {
	for _, val := range m.Fields {
		if val.Name == name {
			return val
		}
	}
	return nil
}

func (m *Model) SaveField(field *Field) {
	for index, fld := range m.Fields {
		if fld.Name == field.Name {
			m.Fields[index] = field
			return
		}
	}
}

func NewField() *Field {
	return &Field{Validator: &FieldValidation{}}
}

func NewModel() *Model {
	return &Model{Fields: []*Field{}}
}
